#include <stdio.h>

void lection() {
    // Почитать про возможности printf

    int a; // Это переменная
    int *p; // А это указатель
    int* q, e; // q - это указатель, а e - это переменная
    // Указатель (англ. pointer) — переменная, диапазон значений которой состоит из адресов ячеек памяти или
    // специального значения — нулевого адреса. Последнее используется для указания того, что в данный момент
    // указатель не ссылается ни на одну из допустимых ячеек.
    p = &a;
    int **pp = &p;
    p = q; // Указатели можно присваивать
    // Не все арифметические операции имеют логическое значение, при использовании их на указатели
    // '*' обознаает три действия: бинарное умножение, обращение сквозь указатель, создание указателя
    // Указатель указывает на адрес, не на ссылку. Ссылка и адрес - разные вещи. Не путать!
    // Адреса есть только у объектов, у переменных. У числовых констант нет адреса памяти, или можно сказать, что они ничего не занимают.
    // Откуда же тогда берутся числовые константы?: 1) часть команды машинного кода 2) компилятор может захотеть выделить память
    // Следствия: 1) адрес невозможно взять у числовых констант 2) адрес нельзя взять у выражений (пример: p = &(a + 2))

    const int b = 8; // Раньше константы были нужны чтобы облегчить работу компилятора, но сейчас компиляторы умные и поэтому
    // константы сейчас используют только для красоты и лаконичности кода.
    const int *t = &b; // Это штука скомпилится. t можно только читать, изменить его не получится. Такой указатель
    // полезен для компилятора. Он гворит что указатель не будет использоваться для изменения памяти.
    //*t = 3; - А вот эта штука не скомпилится, потому что t указывает на константный тип
    int *const s = &a;
    *s = 3;
    //s = &b; - Вот эта штука не скомпилится.
}

int f(int x) {
    ++x;
    return x;
}

int g(int *x) {
    ++ *x;
    return *x;
}

int main() {
    int x = 2;
    int y = f(x);
    printf("%d %d\n", x, y);
    // Переменная x не изменяется так как в f() мы передаем только копию(значение). Такая передача называется передача по значению.
    // Почему scanf нужны &, а printf не нужны?: printf - функция, которая берет только значения переменных, ей не требуется менять переменные.
    // Функция scanf получает указатели на переменные, чтобы она смогла изменить значения переменных.
    x = 2;
    y = g(&x);
    printf("%d %d\n", x, y);
    // scanf()/printf() - функции работы с кансолью. fscanf(f, "%d", &a)/fprintf(f, "%d", a) - функции рабты с файлом.
    // FILE *f = fopen("имя", "режимы: (читать (r - read), писать (w - write), и другие)") - функция открывающая файл, возвращает указатель
    // fclose(f) - закрытие файла. Когда мы открываем файл обычно ОС запрещает другим программам им пользоваться.
    // Пример: нельзя удалить файл который используется. Современные ОС способны закрывать файлы за тобой, но лучше закрывать самому
    // Что будет есди файл не закрыть?: 1) Другие программы не смогут им пользоваться 2) Не освобождаем память -> теряем память
    // 3) Если мы писали в файл и не закрыли его, то нет гарантии что информации запишется в файл так как функция записи
    // в файл функция буферизированная, то есть сначала пишет в буфер а потом скидывает его в файл.
    // Как функция fopen() обозначает неудачу?: Есть соглашение, что если указатель указывает на NULL(нулевое значение), значит что-то не так
     int *p; // Куда указывает p?: Куда-то. p указывает на мусор, на случайный адрес. При запусках программы будут разные значения.
     int *q = NULL; // q указывает на нулевое значение.

     // Функции двоичного вводы/ввывода: fread()/fwrite. 1 порция - это 4 байта
     // Зачем нужно: например если в файле картинка. Если будем считывать картинку через fscanf(), то ее размер увелиится в 4 раза!
     // Один байт картинки конвертируется в 4 байта нулей и единиц + конвертирование не самый быстрый процесс. Итог: используем fread().
}
